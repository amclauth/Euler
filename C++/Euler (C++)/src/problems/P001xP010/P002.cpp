#include <string>
#include "../../base/problem.h"
#include <math.h>
#include "../../util/basic.h"
#include <iostream>

/**
 * P002<br>
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 * By starting with 1 and 2, the first 10 terms will be:<br>
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...<br>
 * By considering the terms in the Fibonacci sequence whose values do not exceed four
 * million, find the sum of the even-valued terms.<br>
 * Ans: 4613732
 */
class P002: public Problem
{
   public:
      P002()
      {
         problem_number = 2;
         variations = 3;
      }
      ~P002()
      {
      }

      std::string execute(int variation)
      {
         switch (variation)
         {
            case 0:
               return to_string(brute());
            case 1:
               return to_string(closedFormItr());
            case 2:
            case -1:
               return to_string(closedForm());
            default:
               return std::string("unavailable");
         }
         return NULL;
      }

   private:
      int brute()
      {
         // just brute force, but it's really fast anyway
         int sum = 0;
         int prev = 1;
         int curr = 2;

         while (curr < 4000000)
         {
            if (curr % 2 == 0)
            {
               sum += curr;
            }
            curr += prev;
            prev = curr - prev;
         }
         return sum;
      }

      /**
       * Note that every 3rd number is even and try to use the closed form of
       * the fibonacci sequence
       */
      int closedFormItr()
      {
         int f = 0;
         int n = 0;
         int sum = 0;
         while (f < 4000000)
         {
            sum += f;
            n += 3;
            f = basic::fibonacci(n);
         }
         return sum;
      }

      /**
       * Use the closed form of fibonacci and the closed form of geometric progression combined
       */
      int closedForm()
      {
         double phi = 0.5 + 0.5 * sqrt(5);
         double phi_cb = pow(phi, 3.0);
         double onephi_cb = pow(1.0 - phi, 3.0);
         unsigned N = floor(log(4000000.0 * sqrt(5) + 0.5) / log(phi));
         N = N / 3;
         int sum = ((1 - pow(phi_cb, N + 1)) / (1 - phi_cb) - (1 - pow(onephi_cb, N + 1)) / (1 - onephi_cb)) / sqrt(5);
         return sum;
      }

};
